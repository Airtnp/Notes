# Cpp Quiz

## Array is sure not pointer!
```c++
int arr[1]; 
int *p;
arr = xxx; // Error 
p = xxx; // OK 

int arr[10]; 
int *p = (int*)malloc(sizeof(int)*10)Ôºõ 
size_t as = sizeof(arr); // 40 
size_t ps = sizeof(p); // 4
```

## Bad, bad VLA
```c++
// Only valid in C99 and optional C11 (GNU11)
int a = 100;
int v[a] = {0};
sizeof(v); // 400! runtime evaluation
```

## aggr-init vs. delete function
* [dis](https://stackoverflow.com/q/33988297/8563711)
```c++
struct Foo {
    Foo(const Foo &) = delete;
};

int main() { Foo bar{}, b2{ Foo{} }; } // OK

class Foo {
    Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // OK

struct Foo {
    explicit Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // Error

struct Foo {
    Foo() = delete;
};
int main() { Foo bar{}; } // OK

struct Foo {
    Foo() = delete;
    Foo(int);
};
int main() { Foo bar{}; } // Error

struct Foo {
private:
    Foo();
};
int main() { Foo bar{}; } // Error

```

## return initializer_list?
```c++
static int a = 1;
static int b = 2;

initializer_list<int> foo() {
    return {a, b} // copy first, return (assign by pointer)
}

int main() {
    auto p = foo(); // Error: dangling pointer
}

```

## void()
```c++
template <typename T>
T foo1() {
    return T();
}

template <typename T>
T foo2() {
    return T{};
}

template <typename T>
void foo3() {
    auto p = new T{};
    delete p;
}

void bar() {
    return void(); // OK
}

void baz() {
    return void{}; // Error
}
```
* std::invoke with return void

## Unicode support
```c++
char* \U0001f431 = "cat" // OK
char* üò∫ = "cat" // Error in GCC

int abc = 1;
int ab\u200c = 1;
int a\u200bc = 1;
int abc\u200 = 1;
```

## Lambda capture forwarding and universal reference
* [dis](https://stackoverflow.com/questions/46118564/alternative-for-stdbind-in-modern-c)
```c++
template<class T>
template<typename F, typename ...Args>
T Container<T>::addTask(F&& func, Args&&... args)
{
    container.emplace_back( [func = std::forward<F>(func),
                             args = std::make_tuple(std::forward<ARGS>(args)...)                                 ] 
                             ()  mutable // make mutable if you want to move the args in to func
                             {
                                 return std::apply(func, std::move(args));
                             });

    //.....
}
```

## Delete element in Cpp
* vector erase-remove
* remove_if
* [dis](https://stackoverflow.com/questions/38468844/erasing-elements-from-unordered-map-in-a-loop)
```c++
std::unordered_map<...> m;
auto it = m.begin();
while (it != m.end())
{
    if (pred(*it))
        it = m.erase(it);
    else
        ++it;
} // UB before Cpp14

std::unordered_map<...> mymap;
std::vector<decltype(mymap)::key_type> vec;
for (auto&& i : mymap)
    if (/*compare i*/)
        vec.emplace_back(i.first);
for (auto&& key : vec)
    mymap.erase(key);
```

## Nested using 
```c++
template <typename T>
template <typename U>
using P = std::is_same<T, U>; // Usable in gcc, failed in clang
                              // ill-formed

```

## vector.resize()
* [discuss](https://www.zhihu.com/question/65997834/answer/237364710)

## tie and tie
```c++
int a = 1, b = 2, c = 3;
std::tie(a, b, c) = {c, a, b};
cout << a << ' ' << b; // 3 3 well-defined?
```

## integer conversion
```c++
sizeof('a' + ' ') == sizeof(int) // true (C even char/bool literal = int)
-1L < 1U // long > int -> convert to long 1 | long == int -> convert to unsigned long 0
```

## default function argument
* ref: SuperNaiveCppLib/notes/CppCon2017/Notes

## launder
* make compiler remove const assumption
```c++
struct X {
    const int n;
    const double d;
};
X* p = new X{7, 8.8};
new (p) X{42, 9.9}; // place new value into p
int b = std::launder(p)->n; // OK, b is 42
int c = p->n; // undefined behavior!
double d = p->d; // undefined behavior!
```

## copy=elision
```c++
struct foo {
    foo() = default;
    foo(cosnt foo&) = delete;
};

int main() {
    auto x = foo(); // prev-17: error! | 17: prvalue copy elision
}
```

## copy-and-swap without customize swap
```c++
class A {
    A(const A&) = default;
    A& operator(const A& rhs) {
        delete();
        A temp(rhs);
        std::swap(*this, temp); // infinite loop! will call copy ctor
        return *this;
    }  
};

```

## string literal is anonymous lvalue
```c++
const_cast<char*>("WTF")[0] = 'd'; // OK, though segmentation fault
true = false; // Failed, 1 is prvalue. <del>Python 2 will allow this</del>
```

## func-macro and identifier
```c++
class A {};

#define A(x) _

int main() {
    A a{}; // OK
    A(a{}); // Error
}
```

## Reference bind to different integer
```c++
char c = 'X';
int& i = c; // Error: promotion causes a prvalue
i = 'J';

void foo(long long int& r) {}
foo(i) // Error
foo(reinterpret_cast<long long int&>(i)) // Potential problem
// same as *reinterpret_cast<T*>(&(i))
```

## rdbuf()
```c++
std::cout << std::cin.rdbuf(); // consume
std::stringstream ss{"TEST"};
std::cin.rdbuf(ss.rdbuf()); // shallow copy
```

## sizeof?
* [discussion](https://stackoverflow.com/questions/46653406/why-does-sizeofmy-arr0-compile-and-equal-sizeofmy-arr0)
* `sizeof(arr)[0] === sizeof(arr[0])` (when `sizeof expression`)
```c++
static uint32_t my_arr[2];
static_assert(sizeof(my_arr) == 8, "");
static_assert(sizeof(my_arr[0]) == 4, "");
static_assert(sizeof(my_arr)[0] == 4, "");
static_assert(sizeof(int)*p == p * 4, ""); // will not parse as size((int*)p);
```

## std::string and SSO
* FBString
> Small strings (<= 23 chars) are stored in-situ without memory allocation. (align as 24 bytes data type)
> Medium strings (24 - 255 chars) are stored in malloc-allocated memory and copied eagerly.
> Large strings (> 255 chars) are stored in malloc-allocated memory and copied lazily.

## auto and private
```c++
class Foo {
    struct Bar { int i; };
public:
    Bar Baz() { return Bar(); } // Your problem...
};

class A {
    class B {};
public:
    typedef B user_t; // Because you choose it
};

int main() {
    Foo f;
    // Foo::Bar b = f.Baz();  // error
    auto b = f.Baz();         // ok
    std::cout << b.i;
}
```
* [discussion](https://stackoverflow.com/questions/13532784/why-can-i-use-auto-on-a-private-type/13532821#13532821)

## __has_trivial_copy
```c++
#include <type_traits>

using namespace std;

struct A {
    A(int v) : a(v) {}
    A(A&&) {a = 1;}
    // A(const A&) { a = 1; }
private:
    A(const A&) = delete;
    int a;
};

int main() {
    A a{1};
    // A b{a};
    cout << is_trivially_copyable<A>::value; // 0 user-defined move ctor
    cout << __has_trivial_copy(A); // 1
    cout << __is_pod(A); // 0
}
```
* before CWG-1734, trivial = implicit + delete

## ambiguous
```c++
1++1; // error
1+ +1 // 2
```

## push_back self element?
* [discussion](https://www.zhihu.com/question/66847606)
* [discussion](https://www.reddit.com/r/cpp/comments/vog1p/a_commonly_unknown_stdvector_pitfall/)
```c++
std::vector<X> vec;
vec.push_back(v.front()); // reallocation may happen before construct new element?
// emplace_back -> new space -> new element -> move/copy
```

## implicit function definition?
* only c90 allows this
```c
#include<stdio.h>

int main() {
    int a = sum(4,6);
    printf("%d",a);
    return 0;
}

int sum(int a,int b) {
    return a + b;
}
```

## injected class name
* The injected class name means that X is declared as a member of X, so that name lookup inside X always finds the current class, not another X that might be declared at the same enclosing scope.
```c++
class X { 
    using T = typename A::A; // However, this fails because A::A implies constructor // though constructor address should not be taken 
    // and constructor cannot be directly call by A::A(...))
};
X x1;
class X::X x2; // class X::X is equal to X
class X::X::X x3; // ...and so on...
```

## Inheritance function
```c++
struct X{ void func(); };
struct Y : public X{};
decltype(&Y::func) // void (X::*)()
```

## Dependent name
* [so]([Derived-template-class](https://stackoverflow.com/questions/4643074/why-do-i-have-to-access-template-base-class-members-through-the-this-pointer))
```c++
template <typename T>
class base {

protected:
    int x;
};

template <typename T>
class derived : public base<T> {

public:
    int f() { 
        return this->x; // base<T>::x || using base<T>::x
    }
};
```

## most vexing parse
```c++
void f(double adouble) {
  int i(int(adouble)); // function declaration int i(int adouble);
}
```


## Attribute parsing
```c++
void f() {
  int y[3];
  y[[] { return 0; }()] = 1;    // error
  int i [[cats::meow([[]])]]; // OK
}
[[attr1]] class [[attr2]] c {...} [[attr3]] x [[attr4]], y;
// attr1 applies to variables x and y
// attr2 applies to class c
// attr3 applies to x's and y's types
// attr4 applies to variable x
```

## Operation associativity and precedence
```c++
a = 1, 2, 3; // Evaluated as (a = 1), 2, 3. Comma operator is left to right
if (c > b > a) // (c > b > a) is treated as ((c > b) > a), associativity of '>' is left to right.
a = b = c; // Evaluated as a = (b = c). = operator is right to left
int a;
(a = 1) = 2; // Builtin assignment returns T& lvalue
```

## Universal ? Rvalue ? Class template argument deduction ?
```c++
struct A {
    template <typename T>
    A(T&& v) {}
};

template <typename T>
struct B {
    B(T&& v) {};
};

int main() {
    int i = 233;
    auto&& v = i; // OK auto -> int&
    int&& m = i; // Error
    auto p = A{i}; // OK T -> int&
    auto q = B<int&>{i}; // OK T -> int&
    auto r = B{i}; // Error T -> int
    T& & p = ... // Error not such grammar
    // difference between class template deduction and template argument deduction
}
```

## Virtual memory exhausted
```c++
namespace std
{
  typedef long unsigned int size_t;
}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
    };

  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;
    };
}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<size_t _Nw>
    struct _Base_bitset
    {
      typedef unsigned long _WordT;

      _WordT _M_w[_Nw];

      constexpr _Base_bitset() noexcept
      : _M_w() { }
    };

  template<size_t _Nb>
    class bitset
    : private _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))>
    {
    };
}

constexpr std::size_t N = 100000;
std::array<std::bitset<N>, N> elems; // The constexpr makes gcc to expand 100000 * 1563 wordT

int main() {}
```

## Bad variant
```c++
#include <variant>
#include <iostream>

using namespace std;

struct A{};
struct B{};
struct C{};
/*
struct D{};
struct E{};
struct F{};
struct G{};
struct H{};
struct I{};
struct J{};
struct K{};
struct L{};
struct M{};
struct N{};
struct O{};
*/

int main() {
  using T = variant<A, B, C/*, D, E, F, G, H, I, J, K, L, M, N, O*/>;
  T a{A{}};
  
  auto p = std::visit( 
    [](auto&& a, auto&&... args) -> T { return a; },
    a, a, a, a
  );
}
```
* another requirement: visitor of std::visit must be exhausive (some return type and can receive all kinds of input value)
* + g++ directly use get<0>, the hinting was soooooooooo sabi
* `variant<T, T>` is ill-formed but without diagnose

## Member specialized (such a dick)
```c++
template <class C> class X
{
public:
   template <class T> void get_as();
   template <> void get_as(); // Error! full-specialization only allowed in namespace scope
};

template <class C> template<>
void X<C>::get_as<double>() {} // Error! Explicitly specialized members need their surrounding class templates to be explicitly specialized as well.

template <> template<>
void X<int>::get_as<double>() {} // So why no just overload
```

## Asso container?
```c++
std::set<T> val{...};
struct MyClass {
    MyClass& operator<<(T& val); // #1
    template <typename U>
    MyClass& operator<<(U& val); // #2
};
for (auto& i: val) {
    MyClass{} << *i; // call #2, i -> const iterator
}
```

## Specialize namespace std
* [discussion](https://stackoverflow.com/questions/8513417/what-can-and-cant-i-specialize-in-the-std-namespace)

## Multiple declaration ? 
* [discussion](https://stackoverflow.com/questions/27895689/declarations-of-a-class-name-and-a-variable-with-the-same-name)

## Conversion Overload
* [discussion](https://stackoverflow.com/questions/47110853/call-to-conversion-operator-instead-of-converting-constructor-in-c17-during-ov)
```c++
#define PRETTY(x) (std::cout << __PRETTY_FUNCTION__ << " : " << (x) << '\n')

struct D;

struct C {
    C() { PRETTY(this);}
    C(const C&) { PRETTY(this);}
    C(const D&) { PRETTY(this);}
};

struct D {
    D() { PRETTY(this);}
    operator C() { PRETTY(this); return C();}
};

D d;
C c(d); // conversion or exact match ?
```

## Without struct/class
```c++
#include <iostream>
#include <vector>
#include <cstdint>
#include <functional>
#include <string>

using namespace std;

size_t hash(string s) {
    return hash<string>{}(s);  // ambiguous 
}
```

## unordered_map before 14
* The order of the elements that are not erased is preserved (this makes it possible to erase individual elements while iterating through the container) (since C++14)
* [discussion-and-solution](https://stackoverflow.com/questions/38468844/erasing-elements-from-unordered-map-in-a-loop)
```c++
std::unordered_map<...> m;
auto it = m.begin();
while (it != m.end())
{
    if (pred(*it))
        it = m.erase(it); // UB before 14
    else
        ++it;
}
```

## A real problem #1
What's wrong with this?
```c++
#include <iostream>
#include <vector>
#include <cstdint>
#include <string>
#include <unordered_map>
#include <functional>
#include <tuple>
#include <cassert>
#include <variant>
using namespace std;
template <std::size_t I, typename ...Args>
auto tuple_index_impl(size_t n, std::tuple<Args...>& tp) {
    // compile-time decide/check return type will not notice runtime branch end conditon
    // if you only write one if constexpr without else, still not notice
    // only if constexpr { ... } else { ... }
    // Also: the return type will deduce differently and failed
    if (I >= sizeof...(Args)) {
        throw std::out_of_range("Out of bound.");
        return {};
    } else {    
        if (n == I) {
            return std::get<I>(tp);
        }
        return tuple_index_impl<I + 1, Args...>(n, tp);
    }
}

template <typename ...Args>
auto tuple_index(size_t n, std::tuple<Args...>& tp) {
    return tuple_index_impl<0, Args...>(n, tp);
}


int main() {
    int i = 2;
    tuple<int, long, int> tp{1, 233, 2};
    /* Question 2: why variant failed (some type ill-formed)
    std::visit(
        [](long long&& c) { 
            std::cout << c << std::endl; 
        },
        tuple_index(i, tp)
    );
    */
}
```

## Short circuit ensure side-effect
* [discussion](https://stackoverflow.com/questions/3635722/short-circuit-evaluation-and-side-effects)
```c++
int main() {
    fork(); // (1 parent and 1 child) 
    fork() && fork() || fork(); // 4(both fork) + 4(both fork) + 2(only child do this fork)
    fork(); // x2 = 20
}
```

## C/C++ about pointer
```c++

#include  <stdio.h>

int main(void)
{
    int* x, *y;
    x = &(y); // fail in C++, valid in C
    y = &(x);
    printf("Hello, world!\n");
    return 0;
}
```

## Ranged-based-for-loop pitfall
* [proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0614r0.html)
```c++
class T {
  std::vector<int> data_;
public:
  std::vector<int>& items() { return data_; }
  // ...
};

{
  T thing = f();
  for (auto& x : thing.items()) {
    // Note: ‚Äúfor (auto& x : f().items())‚Äù is WRONG
    mutate(&x);
    log(x);
  }
}
```
* The wrong is because 
```c++
auto&& temp = f().items(); // This will not extend lifetime! Causes dangling reference
```